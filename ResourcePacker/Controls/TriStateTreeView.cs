#region Copyright 2022 Vonhoff, MaxtorCoder

/* This file is part of ResourcePackerGUI.
 *
 * ResourcePackerGUI is free software: you can redistribute it and/or modify it under the terms of the
 * GNU General Public License as published by the Free Software Foundation, either version 3 of the License,
 * or (at your option) any later version.
 *
 * ResourcePackerGUI is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
 * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with ResourcePackerGUI.
 * If not, see <https://www.gnu.org/licenses/>.
 */

#endregion

using System.Drawing.Imaging;
using ResourcePacker.Extensions;

namespace ResourcePacker.Controls
{
    public partial class TriStateTreeView : UserControl
    {
        /// <summary>
        /// <see cref="_ignoreClickAction"/> is used to ignore messages generated by setting the <c>Checked</c> flag in code. <br/>
        /// Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c>, the Checked state will be lost otherwise.
        /// </summary>
        private int _ignoreClickAction;

        private bool _readOnly;

        public TriStateTreeView()
        {
            InitializeComponent();
            InitializeCheckboxGraphics();
        }

        protected override CreateParams CreateParams
        {
            get
            {
                var cp = base.CreateParams;
                cp.ExStyle |= 0x02000000;
                return cp;
            }
        }

        public event EventHandler<TreeViewEventArgs>? AfterStateChanged;

        public event EventHandler<TreeViewEventArgs>? NodeStateChanged;

        public bool ReadOnly
        {
            get => _readOnly;
            set
            {
                if (_readOnly == value)
                {
                    return;
                }

                _readOnly = value;
                SetReadonlyGraphics(value);
            }
        }

        private void SetReadonlyGraphics(bool enabled)
        {
            foreach (var node in treeView.Nodes.CollectAll())
            {
                switch (node.StateImageIndex)
                {
                    case <= 3 when enabled:
                        node.StateImageIndex += 3;
                        break;
                    case > 3 when !enabled:
                        node.StateImageIndex -= 3;
                        break;
                }
            }
        }

        /// <summary>
        /// CheckedState is an enum of all allowable nodes states.
        /// </summary>
        public enum CheckedState
        {
            Unchecked,
            Checked,
            Mixed
        }

        public TreeNodeCollection Nodes => treeView.Nodes;

        /// <summary>
        /// Disables any redrawing of the tree view.
        /// </summary>
        public void BeginUpdate()
        {
            treeView.BeginUpdate();
        }

        /// <summary>
        /// Enables the redrawing of the tree view.
        /// </summary>
        public void EndUpdate()
        {
            treeView.EndUpdate();
        }

        /// <summary>
        /// Expands all the tree nodes.
        /// </summary>
        public void ExpandAll()
        {
            treeView.ExpandAll();
        }

        private static void UpdateChildState(TreeNodeCollection nodes, int treeNodeStateImageIndex,
                    bool treeNodeChecked, bool changeUninitializedNodesOnly)
        {
            foreach (TreeNode child in nodes)
            {
                if (changeUninitializedNodesOnly && child.StateImageIndex != -1)
                {
                    continue;
                }

                child.StateImageIndex = treeNodeStateImageIndex;
                child.Checked = treeNodeChecked;

                if (child.Nodes.Count > 0)
                {
                    UpdateChildState(child.Nodes, treeNodeStateImageIndex, treeNodeChecked, changeUninitializedNodesOnly);
                }
            }
        }

        /// <summary>
        /// Helper function to notify parent it may need to use 'mixed' state.
        /// </summary>
        /// <param name="treeNode">The tree node to update the parent from.</param>
        private static void UpdateParentState(TreeNode treeNode)
        {
            while (true)
            {
                var origStateImageIndex = treeNode.StateImageIndex;
                var hasCheckedNodes = false;
                var hasUncheckedNodes = false;
                var hasMixedNodes = false;

                // The parent needs to know how many of it's children are Checked or Mixed.
                foreach (TreeNode child in treeNode.Nodes)
                {
                    if (child.StateImageIndex == (int)CheckedState.Checked)
                    {
                        hasCheckedNodes = true;
                    }
                    else if (child.StateImageIndex == (int)CheckedState.Mixed)
                    {
                        hasMixedNodes = true;
                        break;
                    }
                    else
                    {
                        hasUncheckedNodes = true;
                    }

                    if (hasCheckedNodes && hasUncheckedNodes)
                    {
                        hasMixedNodes = true;
                        break;
                    }
                }

                // Determines the parent's new image state.
                if (hasMixedNodes)
                {
                    treeNode.StateImageIndex = (int)CheckedState.Mixed;
                }
                else
                {
                    if (hasUncheckedNodes)
                    {
                        if (!hasCheckedNodes)
                        {
                            treeNode.Checked = false;
                        }
                    }
                    else
                    {
                        treeNode.Checked = true;
                    }

                    treeNode.StateImageIndex = hasCheckedNodes switch
                    {
                        true when !hasUncheckedNodes => treeNode.Checked ? (int)CheckedState.Checked : (int)CheckedState.Mixed,
                        true => (int)CheckedState.Mixed,
                        _ => treeNode.Checked ? (int)CheckedState.Mixed : (int)CheckedState.Unchecked
                    };
                }

                if (origStateImageIndex != treeNode.StateImageIndex && treeNode.Parent != null)
                {
                    // Parent's state has changed, notify the parent's parent.
                    treeNode = treeNode.Parent;
                    continue;
                }

                break;
            }
        }

        private void AfterCheck(object sender, TreeViewEventArgs e)
        {
            NodeStateChanged?.Invoke(sender, new TreeViewEventArgs(e.Node));

            if (_ignoreClickAction > 0)
            {
                return;
            }

            // Changes are made to the tree, ignore any other change requests.
            _ignoreClickAction++;

            // The checked state has already been changed, we just need to update the state index
            // Node is either ticked or un-ticked.
            // Ignore mixed state, as the node is still only ticked or un-ticked regardless of state of children.
            var treeNode = e.Node;
            if (treeNode != null)
            {
                treeNode.StateImageIndex = treeNode.Checked ? (int)CheckedState.Checked : (int)CheckedState.Unchecked;

                // Force all children to inherit the same state as the current node.
                if (treeNode.Nodes.Count > 0)
                {
                    UpdateChildState(treeNode.Nodes, treeNode.StateImageIndex, treeNode.Checked, false);
                }

                // Populate state up the tree, possibly resulting in parents with mixed state.
                if (treeNode.Parent != null)
                {
                    UpdateParentState(treeNode.Parent);
                }
            }

            _ignoreClickAction--;
            AfterStateChanged?.Invoke(sender, e);
        }

        private void AfterExpand(object sender, TreeViewEventArgs e)
        {
            if (e.Node?.Nodes == null)
            {
                return;
            }

            // We're making changes to the tree, ignore any other change requests.
            _ignoreClickAction++;
            UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true);
            _ignoreClickAction--;
        }

        /// <summary>
        /// Generates the required checkbox graphics when necessary.
        /// </summary>
        private void InitializeCheckboxGraphics()
        {
            treeView.StateImageList ??= new ImageList();

            for (var i = treeView.StateImageList.Images.Count; i < 3; i++)
            {
                // Creates a bitmap which holds the relevant check box style
                // see http://msdn.microsoft.com/en-us/library/ms404307.aspx and
                // http://msdn.microsoft.com/en-us/library/system.windows.forms.checkboxrenderer.aspx

                var bitmap = new Bitmap(16, 16);
                var graphics = Graphics.FromImage(bitmap);

                switch (i)
                {
                    case 0:
                    {
                        CheckBoxRenderer.DrawCheckBox(graphics, Point.Empty,
                            System.Windows.Forms.VisualStyles.CheckBoxState.UncheckedNormal);
                        break;
                    }
                    case 1:
                    {
                        CheckBoxRenderer.DrawCheckBox(graphics, Point.Empty,
                            System.Windows.Forms.VisualStyles.CheckBoxState.CheckedNormal);
                        break;
                    }
                    case 2:
                    {
                        CheckBoxRenderer.DrawCheckBox(graphics, Point.Empty,
                            System.Windows.Forms.VisualStyles.CheckBoxState.MixedNormal);
                        break;
                    }
                    default:
                    {
                        return;
                    }
                }

                treeView.StateImageList.Images.Add(bitmap);
            }

            // Generate their disabled counterparts preserving the alpha channel.
            foreach (Bitmap image in treeView.StateImageList.Images)
            {
                Image bitmap = new Bitmap(image.Width, image.Height, image.PixelFormat);

                // Create the ImageAttributes object and apply the ColorMatrix
                var attributes = new ImageAttributes();
                var colorMatrix = new ColorMatrix(new[]
                {
                    new[] {0.299f, 0.299f, 0.299f, 0f, 0f},
                    new[] {0.587f, 0.587f, 0.587f, 0f, 0f},
                    new[] {0.114f, 0.114f, 0.114f, 0f, 0f},
                    new[] {0f, 0f, 0f, 1f, 0f},
                    new[] {0f, 0f, 0f, 0f, 1f}
                });

                attributes.SetColorMatrix(colorMatrix);

                // Use a new Graphics object from the new image.
                using (var graphics = Graphics.FromImage(bitmap))
                {
                    // Draw the original image using the ImageAttributes created above.
                    graphics.DrawImage(image,
                        new Rectangle(0, 0, bitmap.Width, bitmap.Height),
                        0, 0, bitmap.Width, bitmap.Height,
                        GraphicsUnit.Pixel,
                        attributes);
                }

                treeView.StateImageList.Images.Add(bitmap);
            }
        }

        private void NodeMouseClick(object sender, TreeNodeMouseClickEventArgs e)
        {
            if (ReadOnly)
            {
                return;
            }

            // Has the checkbox been clicked? If not, discard it.
            var info = treeView.HitTest(e.X, e.Y);
            if (info.Location != TreeViewHitTestLocations.StateImage)
            {
                return;
            }

            // Toggle the node's checked status. This will then fire OnAfterCheck.
            var treeNode = e.Node;
            treeNode.Checked = !treeNode.Checked;
        }
    }
}