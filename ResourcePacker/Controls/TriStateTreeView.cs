using ResourcePacker.Properties;

namespace ResourcePacker.Controls
{
    /// <summary>
    /// A Tri-State TreeView designed for on-demand populating of the tree.
    /// </summary>
    /// <remarks>
    /// 'Mixed' nodes retain their checked state, meaning they can be checked or unchecked according to their current state
    /// Tree can be navigated by keyboard (cursor keys &amp; space)
    /// No need to do anything special in calling code.
    /// </remarks>
    public class TriStateTreeView : TreeView
    {
        /// <summary>
        /// IgnoreClickAction is used to ignore messages generated by setting the node.Checked flag in code. <br/>
        /// Do not set <c>e.Cancel = true</c> in <c>OnBeforeCheck</c>, otherwise the Checked state will be lost
        /// </summary>
        private int _ignoreClickAction;

        public TriStateTreeView()
        {
            StateImageList = new ImageList();
            StateImageList.Images.Add(Images.checkbox_unchecked);
            StateImageList.Images.Add(Images.checkbox_checked);
            StateImageList.Images.Add(Images.checkbox_tristate);
        }

        /// <summary>
        /// CheckedState is an enum of all allowable nodes states.
        /// </summary>
        public enum CheckedState
        {
            UnChecked,
            Checked,
            Mixed
        }

        /// <summary>
        /// TriStateStyles is an enum of all allowable tree styles
        /// All styles check children when parent is checked
        /// Installer automatically checks parent if all children are checked, and un-checks parent if at least one child is unchecked
        /// Standard never changes the checked status of a parent
        /// </summary>
        public enum TriStateStyles
        {
            Standard = 0,
            Installer
        }

        /// <summary>
        /// Create a private member for the tree style, and allow it to be set on the property sheer.
        /// </summary>
        [System.ComponentModel.Category("Tri-State Tree View")]
        [System.ComponentModel.DisplayName("Style")]
        [System.ComponentModel.Description("Style of the Tri-State Tree View")]
        public TriStateStyles TriStateStyleProperty { get; set; } = TriStateStyles.Standard;

        /// <summary>
        /// Called after a node is checked.
        /// Forces all children to inherit current state, and notifies parents they may need to become 'mixed'.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnAfterCheck(TreeViewEventArgs e)
        {
            base.OnAfterCheck(e);

            if (_ignoreClickAction > 0)
            {
                return;
            }

            // Changes are made to the tree, ignore any other change requests.
            _ignoreClickAction++;

            // The checked state has already been changed, we just need to update the state index

            // Node is either ticked or un-ticked.
            // Ignore mixed state, as the node is still only ticked or un-ticked regardless of state of children.
            var treeNode = e.Node;
            if (treeNode != null)
            {
                treeNode.StateImageIndex = treeNode.Checked ? (int)CheckedState.Checked : (int)CheckedState.UnChecked;
            }

            // Force all children to inherit the same state as the current node.
            if (treeNode?.Nodes != null)
            {
                UpdateChildState(treeNode.Nodes, treeNode.StateImageIndex, treeNode.Checked, false);
            }

            // Populate state up the tree, possibly resulting in parents with mixed state.
            if (treeNode?.Parent != null)
            {
                UpdateParentState(treeNode.Parent);
            }

            _ignoreClickAction--;
        }

        /// <summary>
        /// Called after a node is expanded. Ensures any new nodes display an 'unchecked' image.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnAfterExpand(TreeViewEventArgs e)
        {
            // If any child node is new, give it the same check state as the current node
            // So if current node is ticked, child nodes will also be ticked
            base.OnAfterExpand(e);

            if (e.Node != null)
            {
                _ignoreClickAction++;   // we're making changes to the tree, ignore any other change requests
                UpdateChildState(e.Node.Nodes, e.Node.StateImageIndex, e.Node.Checked, true);
                _ignoreClickAction--;
            }
        }

        /// <summary>
        /// Called once before window displayed.
        /// Disables default Checkbox functionality and ensures all nodes display an 'unchecked' image.
        /// </summary>
        protected override void OnCreateControl()
        {
            base.OnCreateControl();
            CheckBoxes = false; // Disable default CheckBox functionality if it's been enabled

            // Give every node an initial 'unchecked' image.
            _ignoreClickAction++; // we're making changes to the tree, ignore any other change requests
            UpdateChildState(Nodes, (int)CheckedState.UnChecked, false, true);
            _ignoreClickAction--;
        }

        /// <summary>
        /// Called on keypress.Used to change node state when Space key is pressed
        /// Invokes OnAfterCheck to do the real work.
        /// </summary>
        /// <param name="e"></param>
        protected override void OnKeyDown(KeyEventArgs e)
        {
            base.OnKeyDown(e);

            // is the keypress a space?If not, discard it
            if (e.KeyCode == Keys.Space)
            {
                // toggle the node's checked status.This will then fire OnAfterCheck
                SelectedNode.Checked = !SelectedNode.Checked;
            }
        }

        /// <summary>
        /// Called when node is clicked by the mouse.Does nothing unless the image was clicked
        /// Invokes OnAfterCheck to do the real work
        /// </summary>
        /// <param name="e"></param>
        protected override void OnNodeMouseClick(TreeNodeMouseClickEventArgs e)
        {
            base.OnNodeMouseClick(e);

            // Has the checkbox been clicked? If not, discard it.
            var info = HitTest(e.X, e.Y);
            if (info.Location != TreeViewHitTestLocations.StateImage)
            {
                return;
            }

            // Toggle the node's checked status.This will then fire OnAfterCheck.
            var treeNode = e.Node;
            treeNode.Checked = !treeNode.Checked;
        }

        /// <summary>
        /// Helper function to replace child state with that of the parent.
        /// </summary>
        /// <param name="nodes">The nodes of the <see cref="TreeNodeCollection"/>.</param>
        /// <param name="stateImageIndex">The state image index.</param>
        /// <param name="isChecked">Whether the child states are checked.</param>
        /// <param name="changeUninitializedNodesOnly">Whether only the uninitialized nodes should change.</param>
        protected void UpdateChildState(TreeNodeCollection nodes, int stateImageIndex, bool isChecked, bool changeUninitializedNodesOnly)
        {
            foreach (TreeNode child in nodes)
            {
                if (changeUninitializedNodesOnly && child.StateImageIndex != -1)
                {
                    continue;
                }

                child.StateImageIndex = stateImageIndex;

                // Override 'checked' state of child with that of parent.
                child.Checked = isChecked;

                if (child.Nodes.Count > 0)
                {
                    UpdateChildState(child.Nodes, stateImageIndex, isChecked, changeUninitializedNodesOnly);
                }
            }
        }

        /// <summary>
        /// Helper function to notify parent it may need to use 'mixed' state.
        /// </summary>
        /// <param name="treeNode">The tree node to update the parent from.</param>
        protected void UpdateParentState(TreeNode? treeNode)
        {
            if (treeNode == null)
            {
                return;
            }

            while (true)
            {
                var origStateImageIndex = treeNode.StateImageIndex;
                int unCheckedNodes = 0, checkedNodes = 0, mixedNodes = 0;

                // The parent needs to know how many of it's children are Checked or Mixed
                foreach (TreeNode tnChild in treeNode.Nodes)
                {
                    if (tnChild.StateImageIndex == (int)CheckedState.Checked)
                    {
                        checkedNodes++;
                    }
                    else if (tnChild.StateImageIndex == (int)CheckedState.Mixed)
                    {
                        mixedNodes++;
                        break;
                    }
                    else
                    {
                        unCheckedNodes++;
                    }
                }

                if (TriStateStyleProperty == TriStateStyles.Installer)
                {
                    // In Installer mode, if all child nodes are checked then parent is checked.=.
                    // If at least one child is unchecked, then parent is unchecked.
                    if (mixedNodes == 0)
                    {
                        treeNode.Checked = unCheckedNodes == 0;
                    }
                }

                // Determine the parent's new Image State.
                if (mixedNodes > 0)
                {
                    // At least one child is mixed, so parent must be mixed.
                    treeNode.StateImageIndex = (int)CheckedState.Mixed;
                }
                else
                {
                    switch (checkedNodes)
                    {
                        case > 0 when unCheckedNodes == 0:
                        {
                            // All children are checked.
                            if (treeNode.Checked)
                            {
                                treeNode.StateImageIndex = (int)CheckedState.Checked;
                            }
                            else
                            {
                                treeNode.StateImageIndex = (int)CheckedState.Mixed;
                            }
                            break;
                        }
                        case > 0:
                        {
                            // Some children are checked, the rest are unchecked.
                            treeNode.StateImageIndex = (int)CheckedState.Mixed;
                        }
                        break;

                        default:
                        {
                            // All children are unchecked.
                            if (treeNode.Checked)
                            {
                                treeNode.StateImageIndex = (int)CheckedState.Mixed;
                            }
                            else
                            {
                                treeNode.StateImageIndex = (int)CheckedState.UnChecked;
                            }
                            break;
                        }
                    }
                }

                if (origStateImageIndex != treeNode.StateImageIndex && treeNode.Parent != null)
                {
                    // Parent's state has changed, notify the parent's parent.
                    treeNode = treeNode.Parent;
                    continue;
                }

                break;
            }
        }
    }
}